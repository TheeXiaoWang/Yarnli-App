import React, { useMemo } from 'react'
import { Line, Html } from '@react-three/drei'
import * as THREE from 'three'
import { useLayerlineStore } from '../../app/stores/layerlineStore.js'
import { approximateTotalVolume } from '../../domain/layerlines/intersections.js'
import MeasurementsOverlay from './MeasurementsOverlay'
import { Pole, Ring0Overlay, RingLines, formatPoleLabel } from './LayerlineViewer/index.js'
import { computePerObjectLayerOrder } from './measurements/utils/layerOrdering.js'


const LayerlineViewer = ({ layers, color = '#00ffaa', markers, meta }) => {
  const grouped = useMemo(() => {
    const baseLayers = (layers || []).filter(
      l => !l.isConnector && !l.isLadder && !l.isTipChain && !l.isEdgeArc && !l.isOffset && !l.isIntersection && !l.isCutEdge
    )
    const byObject = new Map()
    for (const layer of baseLayers) {
      const id = layer.objectId ?? 'unknown'
      if (!byObject.has(id)) byObject.set(id, [])
      for (const poly of layer.polylines) byObject.get(id).push(poly)
    }
    return byObject
  }, [layers])

  const { settings } = useLayerlineStore()

  // Extract priorities if present in markers/meta passed via store
  const priorities = useMemo(() => {
    const ids = new Set(layers.map(l => l.objectId).filter(Boolean))
    const map = new Map()
    // Prefer rank if provided so P0 = strongest
    ids.forEach((id) => {
      const rank = meta?.ranks?.[id]
      if (typeof rank === 'number') map.set(id, rank)
      else map.set(id, (meta?.priorities?.[id] ?? 0))
    })
    return map
  }, [layers, meta])

  const linesAsV3 = useMemo(() => {
    // Stratified cap per object to avoid one object starving others
    const capTotal = Math.max(1, settings.renderMaxLayers || 400)
    // flatten counts
    const entries = Array.from(grouped.entries()) // [objectId, polys]
    const totalLines = entries.reduce((a, [, p]) => a + p.length, 0)
    if (totalLines <= capTotal) {
      return entries.flatMap(([, polys]) => polys.map(([...pts]) => pts.map(([x, y, z]) => new THREE.Vector3(x, y, z))))
    }
    // allocate at least 1 per object, then proportionally to lines
    const kept = []
    let remaining = capTotal
    const allocations = entries.map(([, polys]) => Math.max(1, Math.floor((polys.length / totalLines) * capTotal)))
    const allocSum = allocations.reduce((a, b) => a + b, 0)
    remaining -= allocSum
    for (let i = 0; i < allocations.length && remaining > 0; i++) { allocations[i]++; remaining-- }
    entries.forEach(([_, polys], idx) => {
      const k = allocations[idx]
      if (polys.length <= k) {
        kept.push(...polys)
      } else {
        const step = (polys.length - 1) / (k - 1)
        for (let i = 0; i < k; i++) kept.push(polys[Math.round(i * step)])
      }
    })
    return kept.map(poly => poly.map(([x, y, z]) => new THREE.Vector3(x, y, z)))
  }, [grouped, settings.renderMaxLayers])

  // Connector/Ladder lines generated by intersections (tip-to-tip orange segments)
  const ladderLines = useMemo(() => {
    const out = []
    for (const l of (layers || [])) {
      if (!l?.isLadder) continue
      for (const poly of (l.polylines || [])) {
        out.push(poly.map(([x, y, z]) => new THREE.Vector3(x, y, z)))
      }
    }
    return out
  }, [layers])

  // Normalize ring0: can be null, a single polyline [[x,y,z]...], or array of polylines
  const ring0Polylines = useMemo(() => {
    const r = markers?.ring0
    if (!r) return []
    if (Array.isArray(r) && r.length > 0) {
      if (Array.isArray(r[0]) && Array.isArray(r[0][0])) {
        return r // array of polylines
      }
      if (Array.isArray(r[0]) && typeof r[0][0] === 'number') {
        return [r] // single polyline
      }
    }
    return []
  }, [markers])

  // Compute approximate volumes for labeling
  const volumes = useMemo(() => {
    const ids = new Set(layers.map(l => l.objectId).filter(Boolean))
    const map = new Map()
    ids.forEach((id) => {
      // find one layer to grab objectId and type via markers or layers (fallback)
      const layer = layers.find(l => l.objectId === id)
      if (!layer) return
      // markers don't carry the full object; we approximate from meta if available
      // As a fallback, infer from ranks/priorities by id not holding transform
      // Instead, we show relative order using priorities if we cannot compute volume here
      map.set(id, null)
    })
    return map
  }, [layers])

  // Shared layer ordering used by overlay and measurements
  const perObjectOrder = useMemo(
    () => computePerObjectLayerOrder(layers, markers),
    [layers, markers]
  )

	  // Per-object order indices and colors for debugging
	  const perObjectOrderLegacy = useMemo(() => {
	    const isRenderable = (l) => !l.isConnector && !l.isLadder && !l.isTipChain && !l.isEdgeArc && !l.isOffset && !l.isIntersection && !l.isCutEdge
	    const idxMap = new WeakMap()
	    const colorMap = new Map()
	    const groups = new Map()
	    const hashColor = (id) => {
	      const s = String(id ?? 'unknown')
	      let h = 0
	      for (let i = 0; i < s.length; i++) h = (h * 31 + s.charCodeAt(i)) % 360
	      return `hsl(${h},70%,60%)`
	    }
	    // Gather poles by object
	    const polesByObj = new Map()
	    for (const p of (markers?.poles || [])) {
	      const oid = p?.objectId ?? 'unknown'
	      if (!polesByObj.has(oid)) polesByObj.set(oid, {})
	      const pos = Array.isArray(p) ? p : p?.p
	      if (p.role === 'start' && Array.isArray(pos)) polesByObj.get(oid).start = pos
	      else if (p.role === 'end' && Array.isArray(pos)) polesByObj.get(oid).end = pos
	    }
	    // Group layers per object (skip flat base faces)
	    for (const l of (layers || [])) {
	      if (!isRenderable(l)) continue
	      const oid = l.objectId ?? 'unknown'
	      if (!groups.has(oid)) groups.set(oid, [])
	      groups.get(oid).push(l)
	      if (!colorMap.has(oid)) colorMap.set(oid, hashColor(oid))
	    }
	    // For each object, sort from start pole â†’ end pole and assign indices
	    groups.forEach((arr, oid) => {
	      const poles = polesByObj.get(oid) || {}
	      let n = null, origin = null
	      if (Array.isArray(poles.start) && Array.isArray(poles.end)) {
	        origin = new THREE.Vector3(poles.start[0], poles.start[1], poles.start[2])
	        const endV = new THREE.Vector3(poles.end[0], poles.end[1], poles.end[2])
	        n = endV.clone().sub(origin)
	        if (n.lengthSq() > 1e-12) n.normalize(); else n = null
	      }
	      const keyFor = (l) => {
	        try {
	          if (n && origin) {
	            const poly = l?.polylines?.[0]
	            if (Array.isArray(poly) && poly.length > 0) {
	              const m = poly[Math.floor(poly.length / 2)]
	              if (Array.isArray(m)) {
	                const v = new THREE.Vector3(m[0], m[1], m[2])
	                return n.dot(v.clone().sub(origin))
	              }
	            }
	          }
	        } catch(_) {}
	        return (l._keyAlongAxis != null) ? l._keyAlongAxis : (l.y ?? 0)
	      }
      // Compute keys and extreme planes for tie-breakers (include base faces)
      const __keys = arr.map(a => (function(){
        try {
          if (n && origin) {
            const poly = a?.polylines?.[0]
            if (Array.isArray(poly) && poly.length > 0) {
              const m = poly[Math.floor(poly.length / 2)]
              if (Array.isArray(m)) {
                const v = new THREE.Vector3(m[0], m[1], m[2])
                return n.dot(v.clone().sub(origin))
              }
            }
          }
        } catch(_) {}
        return (a._keyAlongAxis != null) ? a._keyAlongAxis : (a.y ?? 0)
      })())
      const __minKey = Math.min(...__keys)
      const __maxKey = Math.max(...__keys)
      const __eps = 1e-6
      const __perimeter = (layer) => {
        try {
          const poly = layer?.polylines?.[0]
          if (!Array.isArray(poly) || poly.length < 2) return 0
          let sum = 0
          for (let i = 0; i < poly.length - 1; i++) {
            const ax = poly[i][0], ay = poly[i][1], az = poly[i][2]
            const bx = poly[i + 1][0], by = poly[i + 1][1], bz = poly[i + 1][2]
            const dx = ax - bx, dy = ay - by, dz = az - bz
            sum += Math.sqrt(dx * dx + dy * dy + dz * dz)
          }
          return sum
        } catch (_) { return 0 }
      }

	      arr.sort((a, b) => keyFor(a) - keyFor(b))
      // Refined sort with extreme-plane tie-breakers to place base faces correctly
      arr.sort((a, b) => {
        const ka = keyFor(a)
        const kb = keyFor(b)
        const dk = ka - kb
        if (Math.abs(dk) > __eps) return dk
        const aOnMin = Math.abs(ka - __minKey) <= __eps
        const bOnMin = Math.abs(kb - __minKey) <= __eps
        const aOnMax = Math.abs(ka - __maxKey) <= __eps
        const bOnMax = Math.abs(kb - __maxKey) <= __eps
        if (aOnMin && bOnMin) return __perimeter(a) - __perimeter(b)
        if (aOnMax && bOnMax) return __perimeter(b) - __perimeter(a)
        return 0
      })

	      for (let i = 0; i < arr.length; i++) idxMap.set(arr[i], i)
	    })
	    return { idxMap, colorMap }
	  }, [layers, markers])


  return (
    <group>
      {/* markers */}
      <Ring0Overlay polylines={ring0Polylines} color={color} />
      {(markers?.poles || []).map((entry, i) => {
        const pos = Array.isArray(entry) ? entry : entry?.p
        if (!pos) return null
        const oid = Array.isArray(entry) ? 'unknown' : (entry?.objectId ?? 'unknown')
        const up = meta?.oval && meta.oval[oid] && meta.oval[oid].poleAxis ? meta.oval[oid].poleAxis : null
        const role = Array.isArray(entry) ? undefined : entry?.role
        // Color code by role: start=green, end=red, unknown=amber
        const colorPole = role==='start' ? '#44ff88' : role==='end' ? '#ff5566' : '#ffcc55'
        const pr = priorities.get(oid) ?? 0
        const vol = meta?.volumes?.[oid]
        return (
          <group key={`pole-${i}`}>
            <Pole position={pos} upDir={up} color={colorPole} />
            <Html position={[pos[0], pos[1] + 0.25, pos[2]]} center style={{ pointerEvents: 'none' }}>
              <div style={{ background: 'rgba(0,0,0,0.55)', color: '#fff', padding: '4px 8px', borderRadius: 6, fontSize: 12 }}>{formatPoleLabel(pr, vol, role)}</div>
            </Html>
          </group>
        )
      })}

      {/* lines */}
      <RingLines layers={linesAsV3} color={color} />

	      {/* Layer order indices overlay */}
	      {settings?.showLayerOrder && layers.map((l, i) => {
	        const ref = l.polylines?.[0]?.[Math.floor((l.polylines?.[0]?.length||1)/2)]
	        if (!ref) return null
        const oid = l.objectId ?? 'unknown'
        const localIdx = perObjectOrder.idxMap.get(l)
        if (localIdx == null) return null
        const tagColor = perObjectOrder.colorMap.get(oid) || '#89bbff'
        const oidShort = String(oid).slice(-4)

	        return (
	          <Html key={`ord-${i}`} position={[ref[0], ref[1] + 0.02, ref[2]]} center style={{ pointerEvents: 'none' }}>
	            <div style={{ background: 'rgba(0,0,0,0.6)', color: '#89bbff', padding: '2px 6px', borderRadius: 4, fontSize: 10, borderLeft: `3px solid ${tagColor}` }}>
	              {localIdx}
              <span style={{ marginLeft: 6, color: '#ccc' }}>({oidShort})</span>
	            </div>
	          </Html>
	        )
	      })}

      {settings?.intersectionHelpers && ladderLines.map((pts, i) => (
        <Line key={`lad-${i}`} points={pts} color={'#ff9e40'} lineWidth={1.5} transparent opacity={0.95} />
      ))}

      {/* Hover debug: if layer has debugSource, show file/function */}
      {layers.map((l, i) => {
        const src = l.debugSource
        if (!src) return null
        const ref = l.polylines?.[0]?.[Math.floor((l.polylines?.[0]?.length||1)/2)]
        if (!ref) return null
        const label = `${src.fn} @ ${src.file} â€¢ ${src.kind}${src.localIndex!=null?` #${src.localIndex}`:''}`
        return (
          <Html key={`dbg-${i}`} position={[ref[0], ref[1]+0.02, ref[2]]} center style={{ pointerEvents: 'none', opacity: 0, transition: 'opacity 0.15s' }} className="ll-debug-label">
            <div style={{ background: 'rgba(0,0,0,0.7)', color: '#ffd966', padding: '2px 6px', borderRadius: 4, fontSize: 10 }}>{label}</div>
          </Html>
        )
      })}

      {/* DEBUG: show intersection boundary markers and cut loops only when helpers are enabled */}
      {settings?.intersectionHelpers && (markers?.boundaries || []).map((b, bi) => (
        <group key={`bd-${bi}`}>
          {(b.points || []).map((p, pi) => (
            <Line key={`bdp-${bi}-${pi}`} points={[[p[0]-0.03,p[1],p[2]],[p[0]+0.03,p[1],p[2]]]} color={'#ff5555'} lineWidth={2} transparent opacity={0.95} />
          ))}
        </group>
      ))}
      {settings?.intersectionHelpers && (markers?.cutLoops || []).map((c, ci) => (
        <Line key={`cl-${ci}`} points={(c.loop||[]).map(([x,y,z])=>new THREE.Vector3(x,y,z))} color={'#ff8888'} lineWidth={1} transparent opacity={0.6} />
      ))}

      {settings.showMeasurements && (
        <MeasurementsOverlay
          layers={layers}
          markers={markers}
          measureEvery={settings.measureEvery}
          azimuthDeg={settings.measurementAzimuthDeg ?? 0}
        />
      )}
    </group>
  )
}

export default LayerlineViewer
