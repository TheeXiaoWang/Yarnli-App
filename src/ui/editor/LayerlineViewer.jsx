import React, { useMemo } from 'react'
import { Line, Html } from '@react-three/drei'
import * as THREE from 'three'
import { useLayerlineStore } from '../../app/stores/layerlineStore.js'
import { approximateTotalVolume } from '../../domain/layerlines/intersections.js'
import MeasurementsOverlay from './MeasurementsOverlay'
import { Pole, Ring0Overlay, RingLines, formatPoleLabel } from './LayerlineViewer/index.js'


const LayerlineViewer = ({ layers, color = '#00ffaa', markers, meta }) => {
  const grouped = useMemo(() => {
    const baseLayers = (layers || []).filter(
      l => !l.isConnector && !l.isLadder && !l.isTipChain && !l.isEdgeArc && !l.isOffset && !l.isIntersection && !l.isCutEdge
    )
    const byObject = new Map()
    for (const layer of baseLayers) {
      const id = layer.objectId ?? 'unknown'
      if (!byObject.has(id)) byObject.set(id, [])
      for (const poly of layer.polylines) byObject.get(id).push(poly)
    }
    return byObject
  }, [layers])

  const { settings } = useLayerlineStore()

  // Extract priorities if present in markers/meta passed via store
  const priorities = useMemo(() => {
    const ids = new Set(layers.map(l => l.objectId).filter(Boolean))
    const map = new Map()
    // Prefer rank if provided so P0 = strongest
    ids.forEach((id) => {
      const rank = meta?.ranks?.[id]
      if (typeof rank === 'number') map.set(id, rank)
      else map.set(id, (meta?.priorities?.[id] ?? 0))
    })
    return map
  }, [layers, meta])

  const linesAsV3 = useMemo(() => {
    // Stratified cap per object to avoid one object starving others
    const capTotal = Math.max(1, settings.renderMaxLayers || 400)
    // flatten counts
    const entries = Array.from(grouped.entries()) // [objectId, polys]
    const totalLines = entries.reduce((a, [, p]) => a + p.length, 0)
    if (totalLines <= capTotal) {
      return entries.flatMap(([, polys]) => polys.map(([...pts]) => pts.map(([x, y, z]) => new THREE.Vector3(x, y, z))))
    }
    // allocate at least 1 per object, then proportionally to lines
    const kept = []
    let remaining = capTotal
    const allocations = entries.map(([, polys]) => Math.max(1, Math.floor((polys.length / totalLines) * capTotal)))
    const allocSum = allocations.reduce((a, b) => a + b, 0)
    remaining -= allocSum
    for (let i = 0; i < allocations.length && remaining > 0; i++) { allocations[i]++; remaining-- }
    entries.forEach(([_, polys], idx) => {
      const k = allocations[idx]
      if (polys.length <= k) {
        kept.push(...polys)
      } else {
        const step = (polys.length - 1) / (k - 1)
        for (let i = 0; i < k; i++) kept.push(polys[Math.round(i * step)])
      }
    })
    return kept.map(poly => poly.map(([x, y, z]) => new THREE.Vector3(x, y, z)))
  }, [grouped, settings.renderMaxLayers])

  // Connector/Ladder lines generated by intersections (tip-to-tip orange segments)
  const ladderLines = useMemo(() => {
    const out = []
    for (const l of (layers || [])) {
      if (!l?.isLadder) continue
      for (const poly of (l.polylines || [])) {
        out.push(poly.map(([x, y, z]) => new THREE.Vector3(x, y, z)))
      }
    }
    return out
  }, [layers])

  // Normalize ring0: can be null, a single polyline [[x,y,z]...], or array of polylines
  const ring0Polylines = useMemo(() => {
    const r = markers?.ring0
    if (!r) return []
    if (Array.isArray(r) && r.length > 0) {
      if (Array.isArray(r[0]) && Array.isArray(r[0][0])) {
        return r // array of polylines
      }
      if (Array.isArray(r[0]) && typeof r[0][0] === 'number') {
        return [r] // single polyline
      }
    }
    return []
  }, [markers])

  // Compute approximate volumes for labeling
  const volumes = useMemo(() => {
    const ids = new Set(layers.map(l => l.objectId).filter(Boolean))
    const map = new Map()
    ids.forEach((id) => {
      // find one layer to grab objectId and type via markers or layers (fallback)
      const layer = layers.find(l => l.objectId === id)
      if (!layer) return
      // markers don't carry the full object; we approximate from meta if available
      // As a fallback, infer from ranks/priorities by id not holding transform
      // Instead, we show relative order using priorities if we cannot compute volume here
      map.set(id, null)
    })
    return map
  }, [layers])

  return (
    <group>
      {/* markers */}
      <Ring0Overlay polylines={ring0Polylines} color={color} />
      {(markers?.poles || []).map((entry, i) => {
        const pos = Array.isArray(entry) ? entry : entry?.p
        if (!pos) return null
        const oid = Array.isArray(entry) ? 'unknown' : (entry?.objectId ?? 'unknown')
        const up = meta?.oval && meta.oval[oid] && meta.oval[oid].poleAxis ? meta.oval[oid].poleAxis : null
        const role = Array.isArray(entry) ? undefined : entry?.role
        // Color code by role: start=green, end=red, unknown=amber
        const colorPole = role==='start' ? '#44ff88' : role==='end' ? '#ff5566' : '#ffcc55'
        const pr = priorities.get(oid) ?? 0
        const vol = meta?.volumes?.[oid]
        return (
          <group key={`pole-${i}`}>
            <Pole position={pos} upDir={up} color={colorPole} />
            <Html position={[pos[0], pos[1] + 0.25, pos[2]]} center style={{ pointerEvents: 'none' }}>
              <div style={{ background: 'rgba(0,0,0,0.55)', color: '#fff', padding: '4px 8px', borderRadius: 6, fontSize: 12 }}>{formatPoleLabel(pr, vol, role)}</div>
            </Html>
          </group>
        )
      })}

      {/* lines */}
      <RingLines layers={linesAsV3} color={color} />
      {settings?.intersectionHelpers && ladderLines.map((pts, i) => (
        <Line key={`lad-${i}`} points={pts} color={'#ff9e40'} lineWidth={1.5} transparent opacity={0.95} />
      ))}

      {/* Hover debug: if layer has debugSource, show file/function */}
      {layers.map((l, i) => {
        const src = l.debugSource
        if (!src) return null
        const ref = l.polylines?.[0]?.[Math.floor((l.polylines?.[0]?.length||1)/2)]
        if (!ref) return null
        const label = `${src.fn} @ ${src.file} â€¢ ${src.kind}${src.localIndex!=null?` #${src.localIndex}`:''}`
        return (
          <Html key={`dbg-${i}`} position={[ref[0], ref[1]+0.02, ref[2]]} center style={{ pointerEvents: 'none', opacity: 0, transition: 'opacity 0.15s' }} className="ll-debug-label">
            <div style={{ background: 'rgba(0,0,0,0.7)', color: '#ffd966', padding: '2px 6px', borderRadius: 4, fontSize: 10 }}>{label}</div>
          </Html>
        )
      })}

      {/* DEBUG: show intersection boundary markers and cut loops only when helpers are enabled */}
      {settings?.intersectionHelpers && (markers?.boundaries || []).map((b, bi) => (
        <group key={`bd-${bi}`}>
          {(b.points || []).map((p, pi) => (
            <Line key={`bdp-${bi}-${pi}`} points={[[p[0]-0.03,p[1],p[2]],[p[0]+0.03,p[1],p[2]]]} color={'#ff5555'} lineWidth={2} transparent opacity={0.95} />
          ))}
        </group>
      ))}
      {settings?.intersectionHelpers && (markers?.cutLoops || []).map((c, ci) => (
        <Line key={`cl-${ci}`} points={(c.loop||[]).map(([x,y,z])=>new THREE.Vector3(x,y,z))} color={'#ff8888'} lineWidth={1} transparent opacity={0.6} />
      ))}

      {settings.showMeasurements && (
        <MeasurementsOverlay layers={layers} markers={markers} measureEvery={settings.measureEvery} />
      )}
    </group>
  )
}

export default LayerlineViewer
